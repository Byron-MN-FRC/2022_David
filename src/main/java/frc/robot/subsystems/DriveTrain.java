// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.FollowerType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.RemoteSensorSource;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;
import com.ctre.phoenix.motorcontrol.TalonFXInvertType;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import com.ctre.phoenix.sensors.PigeonIMU;
import com.ctre.phoenix.sensors.PigeonIMU_StatusFrame;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.DriveConstants;
import frc.robot.RobotContainer;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonFX leftFollower;
    private WPI_TalonFX rightFollower;
    private PigeonIMU pigeon;
    private WPI_TalonFX rightMaster;
    private WPI_TalonFX leftMaster;
    private DifferentialDrive differentialDrive1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    TalonFXInvertType _rightInvert = TalonFXInvertType.CounterClockwise; // Same as invert = "false"
    TalonFXInvertType _leftInvert = TalonFXInvertType.Clockwise; // Same as invert = "true"
    TalonFXConfiguration _rightConfig = new TalonFXConfiguration();
    TalonFXConfiguration _leftConfig = new TalonFXConfiguration();

    Joystick stick = null;

    /**
    *
    */
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        leftFollower = new WPI_TalonFX(1);

        rightFollower = new WPI_TalonFX(3);

        pigeon = new PigeonIMU(4);

        rightMaster = new WPI_TalonFX(2);

        leftMaster = new WPI_TalonFX(0);

        differentialDrive1 = new DifferentialDrive(leftMaster, rightMaster);
        addChild("Differential Drive 1", differentialDrive1);
        differentialDrive1.setSafetyEnabled(true);
        differentialDrive1.setExpiration(0.1);
        differentialDrive1.setMaxOutput(1.0);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // Configure the Drive Motors
        driveTrainMotorConfiguration();
        pigeonReset();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void driveWithStick() {
        if (stick == null) {
            stick = RobotContainer.getInstance().getCommandStick();
        }
        differentialDrive1.arcadeDrive(stick.getY(), -stick.getTwist(), true);
    }

    public void closedLoopTurn(double angle) {
        // zeroSensors();
        System.out.print("[closedLoopTurn]  ");
        System.out.println(angle);

        rightMaster.set(ControlMode.MotionMagic, 0, DemandType.AuxPID, angle * 10);
        leftMaster.follow(rightMaster, FollowerType.AuxOutput1);
        // rightFollower.follow(rightMaster);
        // leftFollower.follow(leftMaster);
    }

    private void pigeonReset() {
        /* Reset Pigeon Configs */
        pigeon.configFactoryDefault();
        pigeon.setStatusFramePeriod(PigeonIMU_StatusFrame.CondStatus_9_SixDeg_YPR, 5, DriveConstants.kTimeoutMs);
        pigeon.setYaw(0, DriveConstants.kTimeoutMs);
        pigeon.setAccumZAngle(0, DriveConstants.kTimeoutMs);
    }

    private void driveTrainMotorConfiguration() {
        // Initialize motors
        rightMaster.configFactoryDefault(DriveConstants.motorTimeoutMS);
        leftMaster.configFactoryDefault(DriveConstants.motorTimeoutMS);
        rightFollower.configFactoryDefault(DriveConstants.motorTimeoutMS);
        leftFollower.configFactoryDefault(DriveConstants.motorTimeoutMS);

        // Initialize Pigeon
        pigeon.configFactoryDefault();

        // Set motors to break
        leftMaster.setNeutralMode(NeutralMode.Brake);
        leftFollower.setNeutralMode(NeutralMode.Brake);
        rightMaster.setNeutralMode(NeutralMode.Brake);
        rightFollower.setNeutralMode(NeutralMode.Brake);

        // WPI drivetrain classes assume by default left & right are opposite
        // - call this to apply + to both sides when moving forward
        // Following line commented out for now. Do we still need to do this?
        // tankDrive.setRightSideInverted(false);

        // Invert motors on right sides
        leftMaster.setInverted(false);
        leftFollower.setInverted(false);
        rightMaster.setInverted(true);
        rightFollower.setInverted(true);

        double ampLimit = DriveConstants.kAmpLimit_DT;
        double ampPeakLimit = DriveConstants.kAmpPeak_DT;

        SupplyCurrentLimitConfiguration currentLimitingFalcons = new SupplyCurrentLimitConfiguration(
                DriveConstants.kEnableCurrentLimiting_DT,
                ampLimit,
                ampPeakLimit,
                DriveConstants.kthreshholdTime);

        rightMaster.configSupplyCurrentLimit(currentLimitingFalcons);

        _leftConfig.primaryPID.selectedFeedbackSensor = FeedbackDevice.IntegratedSensor; // Local Feedback Source

        // * Configure the Remote (Left) Talon's selected sensor as a remote sensor for
        // * the right Talon

        _rightConfig.remoteFilter0.remoteSensorDeviceID = leftMaster.getDeviceID(); // Device ID of Remote Source
        _rightConfig.remoteFilter0.remoteSensorSource = RemoteSensorSource.TalonSRX_SelectedSensor; // Remote Source
                                                                                                    // Type

        // * Now that the Left sensor can be used by the master Talon, set up the Left
        // * (Aux) and Right (Master) distance into a single Robot distance as the
        // * Master's Selected Sensor 0.

        setRobotDistanceConfigs(_rightInvert, _rightConfig);
        // FPID for Distance
        _rightConfig.slot0.kF = DriveConstants.kGains_Distanc.kF;
        _rightConfig.slot0.kP = DriveConstants.kGains_Distanc.kP;
        _rightConfig.slot0.kI = DriveConstants.kGains_Distanc.kI;
        _rightConfig.slot0.kD = DriveConstants.kGains_Distanc.kD;
        _rightConfig.slot0.integralZone = DriveConstants.kGains_Distanc.kIzone;
        _rightConfig.slot0.closedLoopPeakOutput = DriveConstants.kGains_Distanc.kPeakOutput;

        // FPID for Distance
        _rightConfig.slot0.kF = DriveConstants.kGains_Distanc.kF;
        _rightConfig.slot0.kP = DriveConstants.kGains_Distanc.kP;
        _rightConfig.slot0.kI = DriveConstants.kGains_Distanc.kI;
        _rightConfig.slot0.kD = DriveConstants.kGains_Distanc.kD;
        _rightConfig.slot0.integralZone = DriveConstants.kGains_Distanc.kIzone;
        _rightConfig.slot0.closedLoopPeakOutput = DriveConstants.kGains_Distanc.kPeakOutput;

        // * Heading Configs

        _rightConfig.remoteFilter1.remoteSensorSource = RemoteSensorSource.Pigeon_Yaw; // This is for a Pigeon over CAN
        _rightConfig.auxiliaryPID.selectedFeedbackSensor = FeedbackDevice.RemoteSensor1; // Set as the Aux Sensor
        _rightConfig.auxiliaryPID.selectedFeedbackCoefficient = 3600.0 / DriveConstants.kPigeonUnitsPerRotation; // Convert
        // Yaw to
        // tenths of
        // a degree

        // * false means talon's local output is PID0 + PID1, and other side Talon is
        // PID0
        // * - PID1 This is typical when the master is the right Talon FX and using
        // Pigeon
        // *
        // * true means talon's local output is PID0 - PID1, and other side Talon is
        // PID0
        // * + PID1 This is typical when the master is the left Talon FX and using
        // Pigeon

        _rightConfig.auxPIDPolarity = false;
        // FPID for Heading
        _rightConfig.slot1.kF = DriveConstants.kGains_Turning.kF;
        _rightConfig.slot1.kP = DriveConstants.kGains_Turning.kP;
        _rightConfig.slot1.kI = DriveConstants.kGains_Turning.kI;
        _rightConfig.slot1.kD = DriveConstants.kGains_Turning.kD;
        _rightConfig.slot1.integralZone = DriveConstants.kGains_Turning.kIzone;
        _rightConfig.slot1.closedLoopPeakOutput = DriveConstants.kGains_Turning.kPeakOutput;

        // Config the neutral deadband.
        _leftConfig.neutralDeadband = DriveConstants.kNeutralDeadband;
        _rightConfig.neutralDeadband = DriveConstants.kNeutralDeadband;

        // *
        // * 1ms per loop. PID loop can be slowed down if need be. For example, - if
        // * sensor updates are too slow - sensor deltas are very small per update, so
        // * derivative error never gets large enough to be useful. - sensor movement is
        // * very slow causing the derivative error to be near zero.

        int closedLoopTimeMs = 1;
        rightMaster.configClosedLoopPeriod(0, closedLoopTimeMs, DriveConstants.kTimeoutMs);
        rightMaster.configClosedLoopPeriod(1, closedLoopTimeMs, DriveConstants.kTimeoutMs);

        // Motion Magic Configs
        _rightConfig.motionAcceleration = 9500; // (distance units per 100 ms) per second
        _rightConfig.motionCruiseVelocity = 17000; // distance units per 100 ms

        // APPLY the config settings
        leftMaster.configAllSettings(_leftConfig);
        leftFollower.configAllSettings(_leftConfig);
        rightMaster.configAllSettings(_rightConfig);
        rightFollower.configAllSettings(_rightConfig);

        // Set status frame periods to ensure we don't have stale data

        // * These aren't configs (they're not persistant) so we can set these after the
        // * configs.

        rightMaster.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, DriveConstants.kTimeoutMs);
        rightMaster.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, DriveConstants.kTimeoutMs);
        rightMaster.setStatusFramePeriod(StatusFrame.Status_14_Turn_PIDF1, 20, DriveConstants.kTimeoutMs);
        rightMaster.setStatusFramePeriod(StatusFrame.Status_10_Targets, 10, DriveConstants.kTimeoutMs);
        leftMaster.setStatusFramePeriod(StatusFrame.Status_2_Feedback0, 5, DriveConstants.kTimeoutMs);

        rightFollower.follow(rightMaster);
        leftFollower.follow(leftMaster);

        // set on call from autonomous
        rightMaster.selectProfileSlot(DriveConstants.kSlot_Distanc, DriveConstants.PID_PRIMARY);
        rightMaster.selectProfileSlot(DriveConstants.kSlot_Turning, DriveConstants.PID_TURN);

    }

    void setRobotDistanceConfigs(TalonFXInvertType masterInvertType, TalonFXConfiguration masterConfig) {
        /**
         * Determine if we need a Sum or Difference.
         * 
         * The auxiliary Talon FX will always be positive in the forward direction
         * because it's a selected sensor over the CAN bus.
         * 
         * The master's native integrated sensor may not always be positive when forward
         * because sensor phase is only applied to *Selected Sensors*, not native sensor
         * sources. And we need the native to be combined with the aux (other side's)
         * distance into a single robot distance.
         */

        /*
         * THIS FUNCTION should not need to be modified. This setup will work regardless
         * of whether the master is on the Right or Left side since it only deals with
         * distance magnitude.
         */

        /* Check if we're inverted */
        if (masterInvertType == TalonFXInvertType.Clockwise) {
            /*
             * If master is inverted, that means the integrated sensor will be negative in
             * the forward direction.
             * 
             * If master is inverted, the final sum/diff result will also be inverted. This
             * is how Talon FX corrects the sensor phase when inverting the motor direction.
             * This inversion applies to the *Selected Sensor*, not the native value.
             * 
             * Will a sensor sum or difference give us a positive total magnitude?
             * 
             * Remember the Master is one side of your drivetrain distance and Auxiliary is
             * the other side's distance.
             * 
             * Phase | Term 0 | Term 1 | Result Sum: -1 *((-)Master + (+)Aux )| NOT OK, will
             * cancel each other out Diff: -1 *((-)Master - (+)Aux )| OK - This is what we
             * want, magnitude will be correct and positive. Diff: -1 *((+)Aux - (-)Master)|
             * NOT OK, magnitude will be correct but negative
             */

            masterConfig.diff0Term = FeedbackDevice.IntegratedSensor; // Local Integrated Sensor
            masterConfig.diff1Term = FeedbackDevice.RemoteSensor0; // Aux Selected Sensor
            masterConfig.primaryPID.selectedFeedbackSensor = FeedbackDevice.SensorDifference; // Diff0 - Diff1
        } else {
            /* Master is not inverted, both sides are positive so we can sum them. */
            masterConfig.sum0Term = FeedbackDevice.RemoteSensor0; // Aux Selected Sensor
            masterConfig.sum1Term = FeedbackDevice.IntegratedSensor; // Local IntegratedSensor
            masterConfig.primaryPID.selectedFeedbackSensor = FeedbackDevice.SensorSum; // Sum0 + Sum1
        }

        /*
         * Since the Distance is the sum of the two sides, divide by 2 so the total
         * isn't double the real-world value
         */
        masterConfig.primaryPID.selectedFeedbackCoefficient = 0.5;
    }

}
